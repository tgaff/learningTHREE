<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Building VR interactives with Three.js</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    html, body { margin:0; padding:0; overflow:hidden;}
    </style>
</head>
<body>
    <script>
    WebVRConfig = {
      // Forces availability of VR mode.
      FORCE_ENABLE_VR: false,
    };
    </script>
    <!-- Assets we'll need - Three.js, controls, and the webVR manager and polyfill -->
    <script src="js/es6-promise.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/three.flycontrols.js"></script>
    <script src="js/three.terrainloader.js"></script>
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>
    <script src="js/webvr-polyfill.js"></script>
    <script src="js/webvr-manager.js"></script>

    <script>
      var WINDOW_WIDTH = window.innerWidth;
      var WINDOW_HEIGHT = window.innerHeight;

      // width and height of the surface we're gonna create
      var WORLD_WIDTH = 2000;
      var WORLD_HEIGHT = 1900;


      // ok, now make the scene
      var scene = new THREE.Scene();

      // Keeps track of time
      var clock = new THREE.Clock();

      // How we will see the scene
      // PerspectiveCamera(fieldOfView in degrees, aspect ratio, nearest seeable dist, farthest visible dist)
      var camera = new THREE.PerspectiveCamera(75, WINDOW_WIDTH / WINDOW_HEIGHT, 1, 5000);


      // position the camera slightly above and in front of the scene
      camera.position.set(0, -199, 75);
      camera.up = new THREE.Vector3(0,0,1);

      // Look at the center of the scene
      camera.lookAt(scene.position);

      /* * * * * * * *  * * * * * * * * *  * * * * *  * * * * * *  *
      // now we create a webGL renderer to render our lovely graphics
      * * * * * * * * * * * * * * * * *  * * * * * *  * * * * * * * */

      var renderer = new THREE.WebGLRenderer({antialias: true});

      // Set the pixel ratio of the screen (for high DPI screens)  (boilerplate)
      renderer.setPixelRatio(window.devicePixelRatio);

      // Set the background of the scene to orangey-red
      renderer.setClearColor(0xffd4a6);

      // Set the renderer to the size of the window
      renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

      // Append the renderer to the DOM
      document.body.appendChild( renderer.domElement );



      /************************************************
        turn on the VR stereoscopic stuff and add a
        manager to let us control it
        **********************************************/


      // Apply VR stereo rendering to renderer
      var effect = new THREE.VREffect(renderer);
      effect.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

      // manager
      var manager = new WebVRManager(renderer, effect);

      console.log('woo');





      /*************************************************
        Digital Elevation Model
      *************************************************/

      // URL to our DEM resource
      var terrainURL = "data/Gale_HRSC_DEM_50m_300x285.bin";

      // Utility to load the DEM data
      var terrainLoader = new THREE.TerrainLoader();

      // We'll need this later
      var surface;

      // Create the plane geometry
      /* In the line below, we also create a PlaneGeometry(width, height, widthSegments, heightSegments).
         You'll see four arguments - these are the width and height of the "world" that we defined above,
         and the number of vertices the plane will have. We set these two values to 299 and 284 -
         the same dimensions as the DEM data, except that it's zero-indexed.
        */
      var geometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_HEIGHT, 299,284);

      // The terrainLoader loads the DEM file and defines a function to be called when the file
      // is successfully downloaded.
      terrainLoader.load(terrainURL, function(data) {
          // Adjust each vertex in the plane to correspond to the height value in the DEM file
          for (var i=0, l = geometry.vertices.length; i < l; i++) {
            geometry.vertices[i].z = data[i] / 65535 * 100;
          }
          // objects in THREE need both geometry and material - texture loader
          var textureLoader = new THREE.TextureLoader();
          var textureURL = "data/Gale_texture_high_4096px.jpg";

          /*
          Remember the geometry is the shape of an object, and the material is what that
          object is made out of? Well think of a texture map as a paint job, or "skin" on
          an object. It's basically an image mapped onto an object's surface.
          */
          textureLoader.load(textureURL, function(texture) {
            var material = new THREE.MeshLambertMaterial({
              map: texture
            });


            // ok now load it all into the scene once we have the texture and the geometry
            // Create surface mesh and add it to the scene
            surface = new THREE.Mesh(geometry, material);
            scene.add(surface);
          });
      });





    </script>

</body>
</html>
